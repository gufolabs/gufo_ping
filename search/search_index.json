{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#the-ping-problem","title":"The Ping Problem","text":"<p>A common way of probing host availability over IP networks is to use ICMP echo probes. Almost every OS is packaged with the famous ping utility. But what if you need to embed the probe just into your Python application? Running system <code>ping</code> is rarely the option. System ping output formats may vary from system to system. Maintaining the application quickly became a road to hell. Embedding a ping into your application may be a better choice.</p> <p>Despite the apparent simplicity, it is not a trivial task. To implement the ping you have to master a system-dependent Raw Sockets magic. Next, you have to implement ICMP packet forging and parsing. There are many pitfalls. Obtaining a high performance is a separate challenge.</p>"},{"location":"#gufo-ping","title":"Gufo Ping","text":"<p>Gufo Ping is the Python asyncio library for IPv4/IPv6 ping probing. It consists of a clean Python API for high-efficient raw sockets manipulation, implemented in the  Rust language with PyO3 wrapper.</p> <p>Pinging host is the simple task:</p> <pre><code>ping = Ping()\nrtt = await ping.ping(\"127.0.0.1\")\n</code></pre> <p>Sending the series of probes is simple too:</p> <pre><code>ping = Ping()\nasync for rtt in ping.iter_rtt(\"127.0.0.1\", count=5):\n    print(rtt)\n</code></pre> <p>Gufo Ping is really fast, allowing to probe 100 000+ hosts at once.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Clean async API.</li> <li>IPv4/IPv6 support.</li> <li>RAW socket probes (POSIX platforms).</li> <li>DGRAM socket probes (Linux only).</li> <li>Preferable probe method autodetection.</li> <li>High-performance.</li> <li>Built with security in mind.</li> <li>Full Python typing support.</li> <li>Editor completion.</li> <li>Well-tested, battle-proven code.</li> </ul>"},{"location":"#on-gufo-stack","title":"On Gufo Stack","text":"<p>This product is a part of Gufo Stack - the collaborative effort  led by Gufo Labs. Our goal is to create a robust and flexible  set of tools to create network management software and automate  routine administration tasks.</p> <p>To do this, we extract the key technologies that have proven themselves  in the NOC and bring them as separate packages. Then we work on API, performance tuning, documentation, and testing. The NOC uses the final result as the external dependencies.</p> <p>Gufo Stack makes the NOC better, and this is our primary task. But other products can benefit from Gufo Stack too. So we believe that our effort will make  the other network management products better.</p>"},{"location":"CHANGELOG/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p> <p>To see unreleased changes, please see the CHANGELOG on the main branch guide.</p>"},{"location":"CHANGELOG/#070-2026-01-13","title":"0.7.0 - 2026-01-13","text":""},{"location":"CHANGELOG/#added","title":"Added","text":"<ul> <li>Datagram socket probe.</li> <li><code>SelectionPolicy</code> to select preferred probe method.</li> </ul>"},{"location":"CHANGELOG/#changed","title":"Changed","text":"<ul> <li>Rust implemenation how handles request ids and sequence number internally.</li> <li>Deprecated typing declarations are removed.</li> </ul>"},{"location":"CHANGELOG/#removed","title":"Removed","text":"<ul> <li>Python 3.9 support.</li> <li><code>accelerated</code> option. Now always enabled when possible.</li> </ul>"},{"location":"CHANGELOG/#infrastructure","title":"Infrastructure","text":"<ul> <li>Rust 1.92</li> </ul>"},{"location":"CHANGELOG/#060-2025-10-13","title":"0.6.0 - 2025-10-13","text":""},{"location":"CHANGELOG/#added_1","title":"Added","text":"<ul> <li>Python 3.14 support.</li> <li><code>gufo-ping</code> command-line tool.</li> </ul>"},{"location":"CHANGELOG/#changed_1","title":"Changed","text":"<ul> <li>Optimized timeouts handling.</li> <li>Reduced allocations and optimized session storage.</li> </ul>"},{"location":"CHANGELOG/#infrastructure_1","title":"Infrastructure","text":"<ul> <li>Use python:3.14-slim-trixie for devcontainer.</li> <li>codecov.io integration.</li> <li>Rust 1.90</li> <li>PyO3 0.26</li> <li>socket2 0.6</li> <li>Ruff 0.14.0</li> <li>Mypy 1.18.2</li> <li>Pytest 8.4.2</li> <li>IPython 9.6.0</li> </ul>"},{"location":"CHANGELOG/#051-2025-08-24","title":"0.5.1 - 2025-08-24","text":""},{"location":"CHANGELOG/#security","title":"Security","text":"<ul> <li>CVE-2023-24816: Bump IPython version</li> </ul>"},{"location":"CHANGELOG/#infrastructure_2","title":"Infrastructure","text":"<ul> <li>IPython 9.4.0</li> <li>ruff 0.11.2</li> </ul>"},{"location":"CHANGELOG/#removed_1","title":"Removed","text":"<ul> <li>Python 3.8 support</li> </ul>"},{"location":"CHANGELOG/#050-2025-03-12","title":"0.5.0 - 2025-03-12","text":""},{"location":"CHANGELOG/#added_2","title":"Added","text":"<ul> <li>ARM64 binary wheels</li> </ul>"},{"location":"CHANGELOG/#infrastructure_3","title":"Infrastructure","text":"<ul> <li>Rust 1.85.0</li> <li>Rust edition 2024</li> </ul>"},{"location":"CHANGELOG/#040-2025-01-29","title":"0.4.0 - 2025-01-29","text":""},{"location":"CHANGELOG/#added_3","title":"Added","text":"<ul> <li>Python 3.13 support</li> </ul>"},{"location":"CHANGELOG/#fixed","title":"Fixed","text":"<ul> <li>#2 BUG: Error setting DSCP/ToS field for IPv6 ICMP packets</li> <li>#4 BUG: Setting ttl fails for IPv6</li> </ul>"},{"location":"CHANGELOG/#removed_2","title":"Removed","text":"<ul> <li>Python 3.8 support</li> </ul>"},{"location":"CHANGELOG/#infrastructure_4","title":"Infrastructure","text":"<ul> <li>Use Python 1.13 in devcontainer</li> <li>Use Ruff for formatting</li> <li>Rust 1.84.0</li> <li>PyO3 0.23</li> <li>mkdocs-material 9.5.44</li> <li>Ruff 0.7.2</li> <li>mypy 1.13.0</li> <li>pytest 8.3.3</li> <li>Coverage 7.6.4</li> <li>Bump GitHub actions</li> </ul>"},{"location":"CHANGELOG/#031-2023-12-11","title":"0.3.1 -- 2023-12-11","text":""},{"location":"CHANGELOG/#added_4","title":"Added","text":"<ul> <li>Python 3.12 support.</li> <li>docs: Fancy front page</li> </ul>"},{"location":"CHANGELOG/#changed_2","title":"Changed","text":"<ul> <li>Use <code>manylinux_2_28</code> instead of <code>manylinux_2_24</code>.</li> </ul>"},{"location":"CHANGELOG/#infrastructure_5","title":"Infrastructure","text":"<ul> <li>devcontainer: YAML formatting on save</li> <li>Rust 1.74.1</li> <li>devcontainer: Use Python 3.12</li> <li>byteorder 1.5</li> <li>pyo3 0.20</li> </ul>"},{"location":"CHANGELOG/#030-2023-05-02","title":"0.3.0 -- 2023-05-02","text":""},{"location":"CHANGELOG/#added_5","title":"Added","text":"<ul> <li>Ping <code>src_addr</code> parameter to set source addresses of outgoing packets.</li> </ul>"},{"location":"CHANGELOG/#changed_3","title":"Changed","text":"<ul> <li>Ping's <code>ttl</code> and <code>tos</code> options are temporary ignored on IPv6</li> <li>docs: license.md renamed to LICENSE.md</li> </ul>"},{"location":"CHANGELOG/#infrastructure_6","title":"Infrastructure","text":"<ul> <li>Adopt ruff</li> <li>Build Python 3.11 wheels for manylinux2014</li> <li>Rust 1.69</li> <li>PyO3 0.18</li> <li>socket2 0.5</li> <li>devcontainer: Move <code>settings</code> to <code>customizations.vscode.settings</code></li> </ul>"},{"location":"CHANGELOG/#024-2022-12-27","title":"0.2.4 - 2022-12-27","text":""},{"location":"CHANGELOG/#fixed_1","title":"Fixed","text":"<ul> <li>Handle \"No route to network/host\" situation correctly</li> </ul>"},{"location":"CHANGELOG/#infrastructure_7","title":"Infrastructure","text":"<ul> <li>Use <code>actions/checkout@v4</code></li> <li>Use <code>actions/cache@v4</code></li> <li>Project structure tests</li> <li>CI workflows tests</li> <li>Rust 1.66.0</li> </ul>"},{"location":"CHANGELOG/#023-2022-11-17","title":"0.2.3 - 2022-11-17","text":""},{"location":"CHANGELOG/#added_6","title":"Added","text":"<ul> <li>Python 3.11 compatibility</li> <li><code>py.typed</code> file for PEP-561 compatibility</li> <li>Add CITATION.cff</li> </ul>"},{"location":"CHANGELOG/#changed_4","title":"Changed","text":"<ul> <li>Reworked wheels builder</li> <li>Move CHANGELOG.md to the project root</li> <li>Rename <code>_fast.py</code> to <code>_fast.pyi</code></li> </ul>"},{"location":"CHANGELOG/#infrastructure_8","title":"Infrastructure","text":"<ul> <li>Rust 1.65.0</li> <li>PyO3 0.17</li> <li>setuptools-rust 1.5.2</li> <li>mkdocs-material 0.8.5</li> <li>Unify Rust setup for Dockerfile and GitHub CI</li> <li>Use Python 3.11 in Devcontainer</li> </ul>"},{"location":"CHANGELOG/#022-2022-05-16","title":"0.2.2 - 2022-05-16","text":""},{"location":"CHANGELOG/#infrastructure_9","title":"Infrastructure","text":"<ul> <li>Rollback to <code>manylinux2014</code> for RHEL7 compatibility.</li> <li>PyO3 0.16.4</li> </ul>"},{"location":"CHANGELOG/#021-2022-04-15","title":"0.2.1 - 2022-04-15","text":""},{"location":"CHANGELOG/#added_7","title":"Added","text":"<ul> <li><code>__version__</code> attribute.</li> </ul>"},{"location":"CHANGELOG/#020-2022-04-14","title":"0.2.0 - 2022-04-14","text":""},{"location":"CHANGELOG/#added_8","title":"Added","text":"<ul> <li>examples/bench-flood.py script.</li> </ul>"},{"location":"CHANGELOG/#changed_5","title":"Changed","text":"<ul> <li>Optimized buffer handling (~10% speedup).</li> <li>Apply BPF filter to raw socket to reduce context switches (Linux).</li> </ul>"},{"location":"CHANGELOG/#infrastructure_10","title":"Infrastructure","text":"<ul> <li>Switch to Rust 1.60.0.</li> </ul>"},{"location":"CHANGELOG/#010-2022-04-11","title":"0.1.0 - 2022-04-11","text":""},{"location":"CHANGELOG/#added_9","title":"Added","text":"<ul> <li>Initial release.</li> </ul>"},{"location":"LICENSE/","title":"License","text":"<p>Copyright \u00a9 2022-2025, Gufo Labs. All rights reserved.</p> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ol> <li>Redistributions of source code must retain the above copyright notice,    this list of conditions and the following disclaimer.</li> <li>Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.</li> <li>Neither the name of Gufo Labs nor the names of its contributors may be used    to endorse or promote products derived from this software without    specific prior written permission.</li> </ol> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>"},{"location":"faq/","title":"FAQ","text":"<pre><code>What is \"Gufo\"?\n</code></pre> <p>Gufo means the Owl in Italian.</p> <pre><code>Why the owls?\n</code></pre> <p>We love owls and the viable parts of our technologies were proven at the project, named \"the Owl\".</p> <pre><code>What is \"Gufo Labs\"?\n</code></pre> <p>Gufo Labs is the Milan-based company specialized on network and IT consulting, and on software research.</p> <pre><code>What is \"Gufo Stack\"?\n</code></pre> <p>We've extracted core components behind the NOC  and released them as independent packages, available under the terms  of the 3-clause BSD license. Our software shares common code quality standards  and is battle-proven under the high load. We hope our key components will help  the engineers and the developers to build reliable networks and robust network  management software.  See more for details.</p>"},{"location":"installation/","title":"Installation","text":"<p>Install with the pip</p> <pre><code>$ pip install gufo_ping\n</code></pre>"},{"location":"installation/#checking-the-installation","title":"Checking the Installation","text":"<p>To check the installation just import the module</p> <pre><code>from gufo.ping import Ping\n</code></pre>"},{"location":"installation/#upgrading","title":"Upgrading","text":"<p>To upgrade existing Gufo Ping installation use pip</p> <pre><code>$ pip install --upgrade gufo_ping\n</code></pre>"},{"location":"installation/#uninstalling","title":"Uninstalling","text":"<p>To uninstall Gufo Ping use pip</p> <pre><code>$ pip uninstall gufo_ping\n</code></pre>"},{"location":"dev/","title":"Gufo Ping: Developer's Guide","text":"<p>This section is intended for Gufo Ping developers and for entities,  including both individuals and companies, interested in contributing to the project.</p> <ul> <li>Developer's Environment</li> <li>Building and Testing</li> <li>Common Tasks</li> <li>Code Quality</li> <li>Code Base</li> <li>Contributing Guide</li> <li>Code of Conduct</li> <li>Supported Platforms</li> <li>Supported Standards</li> </ul>"},{"location":"dev/CODE_OF_CONDUCT/","title":"Gufo Stack Code of Conduct","text":"<p>Gufo Stack are the tools built by people for people. We aim to create a respectful, collaborative, and constructive community where everyone can contribute to building better software.</p>"},{"location":"dev/CODE_OF_CONDUCT/#the-rule","title":"The Rule","text":"<p>\u201cAnd as you wish that others would do to you, do so to them.\u201d</p> <p>-- Luke 6:31</p>"},{"location":"dev/CODE_OF_CONDUCT/#the-note","title":"The Note","text":"<p>This principle is universal. Similar wisdom can be found in many traditions:</p> <ul> <li>Confucius: \u201cDo not impose on others what you do not wish for yourself.\u201d (Analects 15:24)</li> <li>Prophet Muhammad (peace be upon him): \u201cNone of you [truly] believes until he loves for his brother what he loves for himself.\u201d (Hadith, Sahih Muslim 45:71)</li> </ul> <p>That\u2019s all.</p>"},{"location":"dev/CONTRIBUTING/","title":"Types of contributions","text":"<p>You can contribute to the Gufo Labs projects in several way. This repo is a place to discuss and collaborate on GitHub! Our team is maintaining this repo to preserve our bandwidth, off topic conversations will be closed.</p>"},{"location":"dev/CONTRIBUTING/#discussions","title":"Discussions","text":"<p>Discussions are where we have conversations.</p> <p>If you'd like help troubleshooting a PR you're working on, have a great new idea, or want to share something amazing you've learned in our docs, join us in discussions.</p>"},{"location":"dev/CONTRIBUTING/#issues","title":"Issues","text":"<p>Issues are used to track tasks that contributors can help with. </p> <p>If you've found bug, or something in the content of the documentation that should be updated, search open issues to see if someone else has reported the same thing. If it's something new, open an issue. We'll use the issue to have a conversation about the problem you want to fix.</p>"},{"location":"dev/CONTRIBUTING/#pull-requests","title":"Pull requests","text":"<p>A pull request is a way to suggest changes in our repository.</p>"},{"location":"dev/codebase/","title":"Project's Code Base","text":"<p>The code base of the project has following structure:</p> <ul> <li><code>.devcontainer/</code> - Developer's container configuration for    VSCode Remote Containers. Just reopen   project in remote container to get ready-to-development   environment.</li> <li> <p><code>.github/</code> - GitHub settings</p> <ul> <li><code>workflows/</code> - GitHub Actions Workflows settings.   Used to run tests and build the documentation.</li> </ul> </li> <li> <p><code>docs/</code> - Mkdocs documentation.</p> </li> <li><code>examples/</code> - Project's examples.</li> <li><code>src/</code> - Project's source code.</li> <li><code>tests/</code> - Project's Pytest test suite.</li> <li><code>.gitignore</code> - Gitignore file.</li> <li><code>Dockerfile</code> - Dockerfile for development container.</li> <li><code>mkdocs.yml</code> - Mkdocs configuration file.</li> <li><code>pyproject.toml</code> - pyproject.toml file for python tools configuration.</li> </ul>"},{"location":"dev/codequality/","title":"Code Quality Guide","text":"<p>We share the common code quality standards between all Gufo Labs projects.</p>"},{"location":"dev/codequality/#python-code-formatting","title":"Python Code Formatting","text":"<p>All Python code must be formatting using ruff code formatter with settings defined in the project's <code>pyproject.toml</code> file.</p>"},{"location":"dev/codequality/#python-code-linting","title":"Python Code Linting","text":"<p>All Python code must pass ruff tests with the project's settings.</p>"},{"location":"dev/codequality/#python-code-static-checks","title":"Python Code Static Checks","text":"<p>All python code must pass Mypy type checks in the <code>strict</code> mode.</p>"},{"location":"dev/codequality/#test-suite-coverage","title":"Test Suite Coverage","text":"<p>The test suite must provide 100% code coverage whenever possible.</p>"},{"location":"dev/codequality/#documentation-standards","title":"Documentation Standards","text":"<ul> <li>Documentation must be clean and mean.</li> </ul>"},{"location":"dev/common/","title":"Developer's Common  Tasks","text":""},{"location":"dev/common/#bump-version","title":"Bump Version","text":"<ul> <li> Change <code>__version__</code> in <code>src/gufo/ping/__init__.py</code></li> <li> Change <code>[package]/version</code> in <code>Cargo.toml</code></li> <li> Add section in <code>CHANGELOG.md</code></li> </ul>"},{"location":"dev/common/#bump-rust-version","title":"Bump Rust Version","text":"<ul> <li> Change <code>RUST_VERSION</code> in <code>tools/build/setup-rust.sh</code></li> </ul>"},{"location":"dev/common/#bump-pyo3-version","title":"Bump pyo3 version","text":"<ul> <li> Change <code>[dependencies]/pyo3</code> in <code>Cargo.toml</code></li> </ul>"},{"location":"dev/environment/","title":"Developer's Environment","text":"<p>To participate in development you need to prepare the developer's environment first. Depending on the preferable tools, your mileage may vary.</p>"},{"location":"dev/environment/#visual-studio-code-dev-container","title":"Visual Studio Code Dev Container","text":"<p>The easiest way to start the development is to use Visual Studio Code with Remote Containers plugin. Just click on the green sign in the lower-left corner and select the \"Reopen in Container\" menu item. You'll get all the required formatting and linting settings out of the box.</p>"},{"location":"dev/platforms/","title":"Supported Platorms","text":""},{"location":"dev/platforms/#binary-wheels","title":"Binary Wheels","text":"<p>Following binary wheels are provided with latest release:</p> OS Arch Libc 3.10 3.11 3.12 3.13 3.14  Linux x86_64 Glibc 2.24 (Debian 9)  Linux aarch64 Glibc 2.24 (Debian 9) <sup>1</sup> <sup>1</sup> <sup>1</sup> <sup>1</sup> <sup>1</sup>  Linux x86_64 Musl 1.1 <sup>2</sup> <sup>2</sup> <sup>2</sup> <sup>2</sup>  Linux aarch64 Musl 1.1 <sup>3</sup> <sup>3</sup> <sup>3</sup> <sup>3</sup> <sup>3</sup>  MacOS x86_64  MacOS arm64 <sup>4</sup> <sup>4</sup> <sup>4</sup> <sup>4</sup> <sup>4</sup> :simple-windows: Windows x86_64 <sup>5</sup> <sup>5</sup> <sup>5</sup> <sup>5</sup> <sup>5</sup>  FreeBSD x86_64 <sup>6</sup> <sup>6</sup> <sup>6</sup> <sup>6</sup> <sup>6</sup> <ol> <li> <p><code>manylinux_2_24_aarch64</code> build failed. Rustc exists with code <code>-9</code>.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>auditwheel stops with: ValueError: Cannot repair wheel, because required library <code>librt.so.1</code> could not be located\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p><code>musllinux_1_1_aarch64</code> build failed. Rustc exists with code <code>-9</code>.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Failed to build on ARM64 platform.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Not supported yet. Needs separate implemetation due to different raw sockets API.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Volonteers are needed.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"dev/standards/","title":"Supported Standards","text":"<p>Gufo Ping implements and is guided by the following standards:</p>"},{"location":"dev/standards/#ietf-rfc","title":"IETF RFC","text":"<ul> <li>RFC-792: Internet Control Message Protocol</li> <li>RFC-1071: Computing the Internet Checksum</li> <li>RFC-2474: Definition of the Differentiated   Services Field (DS Field) in the IPv4 and IPv6 Headers</li> <li>RFC-4443: Internet Control Message Protocol (ICMPv6)   for the Internet Protocol Version 6 (IPv6) Specification</li> </ul>"},{"location":"dev/standards/#python-pep","title":"Python PEP","text":"<ul> <li>PEP8: Style Guide for Python Code</li> <li>PEP561: Distributing and Packaging Type Information</li> </ul>"},{"location":"dev/testing/","title":"Building and Testing","text":"<p>Before starting building and testing package set up  Developer's Environment first. From here and below we consider the shell's current directory matches the project's root directory.</p>"},{"location":"dev/testing/#building-package","title":"Building Package","text":"<p>To test the package build run:</p> <pre><code>$ python -m build --sdist --wheel\n</code></pre> <p>Compiled packages will be available in the <code>dist/</code> directory.</p>"},{"location":"dev/testing/#rebuilding-rust-modules","title":"Rebuilding Rust Modules","text":"<p>To rebuild Rust modules for debug and testing:</p> <pre><code>$ python -m pip install --editable .\n</code></pre>"},{"location":"dev/testing/#running-tests","title":"Running tests","text":"<p>Rebuild rust modules, if changed:</p> <pre><code>python -m pip install --editable .\n</code></pre> <p>To run the test suit:</p> <pre><code>$ pytest -vv\n</code></pre>"},{"location":"dev/testing/#running-lints","title":"Running Lints","text":"<p>All lints are checked as part of GitHub Actions Workflow. You may run lints manually before committing to the project.</p>"},{"location":"dev/testing/#check-formatting","title":"Check Formatting","text":"<p>Python Code Formatting is the mandatory requirement in our Code Quality standards. To check code formatting run:</p> <pre><code>$ ruff format --check examples/ src/ tests/\n</code></pre> <p>To fix formatting errors run: <pre><code>$ ruff format examples/ src/ tests/\n</code></pre></p> <p>We recommend setting python code formatting on file saving (Done in VS Code Dev Container out of the box).</p>"},{"location":"dev/testing/#python-code-lints","title":"Python Code Lints","text":"<p>Python Code Linting is the mandatory requirement in our Code Quality standards. To check code for linting errors run:</p> <pre><code>$ ruff check examples/ src/ tests/\n</code></pre>"},{"location":"dev/testing/#python-code-static-checks","title":"Python Code Static Checks","text":"<p>Python Code Static Checks is the mandatory requirement in our Code Quality standards. To check code for typing errors run:</p> <pre><code>$ mypy --strict src/\n</code></pre>"},{"location":"dev/testing/#python-test-code-coverage-check","title":"Python Test Code Coverage Check","text":"<p>To evaluate code coverage run tests:</p> <pre><code>$ coverage run -m pytest -vv\n</code></pre> <p>To report the coverage after the test run:</p> <pre><code>$ coverage report\n</code></pre> <p>To show line-by-line coverage:</p> <pre><code>$ coverage html\n</code></pre> <p>Then open <code>dist/coverage/index.html</code> file in your browser.</p>"},{"location":"dev/testing/#building-documentation","title":"Building Documentation","text":"<p>To rebuild and check documentation run</p> <pre><code>$ mkdocs serve\n</code></pre> <p>We recommend using Grammarly service to check documentation for common errors.</p>"},{"location":"examples/","title":"Gufo Ping Examples","text":"<ul> <li>single: Send single ICMP request.</li> <li>series: Send series of the requests.</li> <li>dgram: Using DGRAM socket.</li> </ul>"},{"location":"examples/dgram/","title":"Gufo Ping Example: Using DGRAM socket.","text":"<p>Gufo Ping uses RAW sockets by default, which is the traditional approach for implementing ping. A common drawback of this method is that the process must run as the root user or, on Linux platforms, have the <code>CAP_NET_RAW</code> capability.</p> <p>Even when only <code>CAP_NET_RAW</code> is granted, the process gains the ability to intercept all host traffic and to forge arbitrary outgoing packets. This makes any pinging process a high-value target for potential attacks.</p> <p>Fortunately, Linux offers an alternative approach: using <code>DGRAM</code> sockets for ICMP echo requests. In this mode, the process\u2019s group ID must fall within the range defined by the <code>net.ipv4.ping_group_range</code> sysctl. With this restriction in place, the process can send only ICMP echo requests and receive only replies to its own requests, which greatly reduces the security impact.</p> <p>Let us send a single ICMP echo request and receive the reply using a <code>DGRAM</code> socket.</p> dgram.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping, SelectionPolicy\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping(policy=SelectionPolicy.DGRAM)\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>The code is straightforward:</p> dgram.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping, SelectionPolicy\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping(policy=SelectionPolicy.DGRAM)\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>We need <code>asyncio.run()</code> to run asynchronous code, so lets import the <code>asyncio</code>.</p> dgram.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping, SelectionPolicy\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping(policy=SelectionPolicy.DGRAM)\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Import <code>sys</code> module to parse the CLI argument.</p> <p>Warning</p> <p>We use <code>sys.argv</code> only for demonstration purposes. Use <code>argsparse</code> or alternatives in real-world applications.</p> dgram.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping, SelectionPolicy\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping(policy=SelectionPolicy.DGRAM)\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p><code>Ping</code> object holds all necessary API, so import it from <code>gufo.ping</code>. We also need <code>SelectionPolicy</code> enum to select desired probing method.</p> dgram.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping, SelectionPolicy\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping(policy=SelectionPolicy.DGRAM)\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Asynchronous code must be executed in the asynchronous functions, or coroutines. So we define our function as <code>async</code>. We expect an address to ping as the <code>addr</code> argument.</p> dgram.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping, SelectionPolicy\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping(policy=SelectionPolicy.DGRAM)\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>First we need to create <code>Ping</code> object. <code>Ping</code> constructor offers a lots of configuration variables for fine-tuning. We're setting <code>policy</code> parameter which is responsible for the probing method selection. <code>SelectionPolicy.DGRAM</code> switches to the <code>DGRAM</code> socket mode. Refer to the SelectionPolicy reference for possible values.</p> dgram.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping, SelectionPolicy\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping(policy=SelectionPolicy.DGRAM)\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Run single ping probe. <code>Ping.ping</code> is asynchronous function, so note the <code>await</code> keyword. The only mandatory parameter is IP address. Gufo Ping detects IPv4/IPv6 usage, so all we need is to pass an address. Function may accept the additional parameters for fine-tuning, Refer to the Ping.ping reference for details.</p> <p>Ping returns:</p> <ul> <li>In case of success: Round-trip-time (RTT), as float, measured in seconds.</li> <li>In case of failure: <code>None</code>.</li> </ul> dgram.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping, SelectionPolicy\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping(policy=SelectionPolicy.DGRAM)\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Lets print the result for our example.</p> dgram.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping, SelectionPolicy\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping(policy=SelectionPolicy.DGRAM)\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>To run our example from command line we need to check we're in <code>__main__</code> module.</p> dgram.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping, SelectionPolicy\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping(policy=SelectionPolicy.DGRAM)\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Lets run our asyncronous <code>main()</code> function via <code>asyncio.run</code> and pass first command-line parameter as address.</p>"},{"location":"examples/dgram/#running","title":"Running","text":"<p>Lets check the success case. Run example as:</p> <pre><code>$ python3 examples/dgram.py 127.0.0.1\n0.000973377\n</code></pre> <p>Ok, we got a measured RTT.</p> <p>Lets check the faulty cause. RFC-5737 defines the special range of addresses - 192.0.2.0/24, which can be used as unresponsible addresses. So, lets ping a 192.0.2.1:</p> <pre><code>$ python3 examples/dgram.py 192.0.2.1\nNone\n</code></pre> <p>After second or so of awaiting we finally got a <code>None</code>, which means our request is timed out.</p>"},{"location":"examples/series/","title":"Gufo Ping Example: Series of Requests","text":"<p>Lets send the sequence of the ICMP echo requests and get the replies.</p> series.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    async for r in ping.iter_rtt(addr, count=5):\n        print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>The code is straightforward:</p> series.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    async for r in ping.iter_rtt(addr, count=5):\n        print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>We need <code>asyncio.run()</code> to run asynchronous code, so lets import the <code>asyncio</code>.</p> series.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    async for r in ping.iter_rtt(addr, count=5):\n        print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Import <code>sys</code> module to parse the CLI argument.</p> <p>Warning</p> <p>We use <code>sys.argv</code> only for demonstration purposes. Use <code>argsparse</code> or alternatives in real-world applications.</p> series.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    async for r in ping.iter_rtt(addr, count=5):\n        print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p><code>Ping</code> object holds all necessary API, so import it from <code>gufo.ping</code>.</p> series.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    async for r in ping.iter_rtt(addr, count=5):\n        print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Asynchronous code must be executed in the asynchronous functions, or coroutines. So we define our function as <code>async</code>. We expect an address to ping as the <code>addr</code> argument.</p> series.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    async for r in ping.iter_rtt(addr, count=5):\n        print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>First we need to create <code>Ping</code> object. <code>Ping</code> constructor offers a lots of configuration variables for fine-tuning. Refer to the  Ping reference for further details. Defaults are good enough for our tutorial, so we ommited them.</p> series.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    async for r in ping.iter_rtt(addr, count=5):\n        print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p><code>Ping.iter_rtt()</code> returns the asynchronous iterator, yielding for each attempt the:</p> <ul> <li>In case of success: Round-trip-time (RTT), as float, measured in seconds.</li> <li>In case of failure: <code>None</code>.</li> </ul> <p>The only mandatory parameter is IP address. Gufo Ping detects IPv4/IPv6 usage, so all we need is to pass an address. Function may accept the additional parameters for fine-tuning, Refer to the Ping.ping reference for details.</p> <p>Note</p> <p>Ping.iter_rtt() is the asynchronous iterator and should be used along with <code>async for</code> construction.</p> series.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    async for r in ping.iter_rtt(addr, count=5):\n        print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Lets print the result of each iteration.</p> series.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    async for r in ping.iter_rtt(addr, count=5):\n        print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>To run our example from command line we need to check we're in <code>__main__</code> module.</p> series.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    async for r in ping.iter_rtt(addr, count=5):\n        print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Lets run our asyncronous <code>main()</code> function via <code>asyncio.run</code> and pass first command-line parameter as address.</p>"},{"location":"examples/series/#running","title":"Running","text":"<p>Lets check the success case. Run example as:</p> <pre><code>$ sudo python3 examples/series.py 127.0.0.1\n0.001022267\n0.001339276\n0.000560895\n0.000832927\n0.001220127\n</code></pre> <p>Ok, we got a measured RTT.</p> <p>Lets check the faulty cause. RFC-5737 defines the special range of addresses - 192.0.2.0/24, which can be used as unresponsible addresses. So, lets ping a 192.0.2.1:</p> <pre><code>$ sudo python3 examples/series.py 192.0.2.1\nNone\nNone\nNone\nNone\nNone\n</code></pre> <p>After second or so of awaiting we finally got a <code>None</code>, which means our request is timed out.</p>"},{"location":"examples/single/","title":"Gufo Ping Example: Single Request","text":"<p>Lets send the single ICMP echo request and get the reply.</p> single.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>The code is straightforward:</p> single.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>We need <code>asyncio.run()</code> to run asynchronous code, so lets import the <code>asyncio</code>.</p> single.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Import <code>sys</code> module to parse the CLI argument.</p> <p>Warning</p> <p>We use <code>sys.argv</code> only for demonstration purposes. Use <code>argsparse</code> or alternatives in real-world applications.</p> single.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p><code>Ping</code> object holds all necessary API, so import it from <code>gufo.ping</code>.</p> single.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Asynchronous code must be executed in the asynchronous functions, or coroutines. So we define our function as <code>async</code>. We expect an address to ping as the <code>addr</code> argument.</p> single.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>First we need to create <code>Ping</code> object. <code>Ping</code> constructor offers a lots of configuration variables for fine-tuning. Refer to the  Ping reference for further details. Defaults are good enough for our tutorial, so we ommited them.</p> single.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Run single ping probe. <code>Ping.ping</code> is asynchronous function, so note the <code>await</code> keyword. The only mandatory parameter is IP address. Gufo Ping detects IPv4/IPv6 usage, so all we need is to pass an address. Function may accept the additional parameters for fine-tuning, Refer to the Ping.ping reference for details.</p> <p>Ping returns:</p> <ul> <li>In case of success: Round-trip-time (RTT), as float, measured in seconds.</li> <li>In case of failure: <code>None</code>.</li> </ul> single.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Lets print the result for our example.</p> single.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>To run our example from command line we need to check we're in <code>__main__</code> module.</p> single.py<pre><code>import asyncio\nimport sys\n\nfrom gufo.ping import Ping\n\n\nasync def main(addr: str) -&gt; None:\n    ping = Ping()\n    r = await ping.ping(addr)\n    print(r)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main(sys.argv[1]))\n</code></pre> <p>Lets run our asyncronous <code>main()</code> function via <code>asyncio.run</code> and pass first command-line parameter as address.</p>"},{"location":"examples/single/#running","title":"Running","text":"<p>Lets check the success case. Run example as:</p> <pre><code>$ sudo python3 examples/single.py 127.0.0.1\n0.000973377\n</code></pre> <p>Ok, we got a measured RTT.</p> <p>Lets check the faulty cause. RFC-5737 defines the special range of addresses - 192.0.2.0/24, which can be used as unresponsible addresses. So, lets ping a 192.0.2.1:</p> <pre><code>$ sudo python3 examples/single.py 192.0.2.1\nNone\n</code></pre> <p>After second or so of awaiting we finally got a <code>None</code>, which means our request is timed out.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>gufo.ping<ul> <li>cli</li> <li>ping</li> <li>proto</li> <li>socket</li> </ul> </li> </ul>"},{"location":"reference/gufo/ping/","title":"gufo.ping","text":"<p>Gufo Ping is the accelerated Python asyncio IPv4/IPv6 ping implementation.</p> <p>Attributes:</p> Name Type Description <code>__version__</code> <code>str</code> <p>Current version.</p>"},{"location":"reference/gufo/ping/#gufo.ping.Ping","title":"<code>Ping</code>","text":"<p>               Bases: <code>object</code></p> <p>High-performance asyncronous ICMPv4/ICMPv6 ping client.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SelectionPolicy</code> <p>Probe selection policy.</p> <code>RAW</code> <code>size</code> <code>int</code> <p>Set outgoing packet's size, including IP header.</p> <code>64</code> <code>src_addr</code> <code>None | str | Iterable[str]</code> <p>Set source address for outgoing packets. Depends upon address family. May be one of: * None - detect source address automatically. * str - containing source address for one address family. * Iterable of strings, containing multiple addresses     which to be distributed among the address families.     First address for given address family will be used.</p> <code>None</code> <code>ttl</code> <code>int | None</code> <p>Set outgoing packet's TTL. Use OS defaults when empty.</p> <p>Warning</p> <p>This option is ignored on IPv6 socket due to issue #4</p> <code>None</code> <code>tos</code> <code>int | None</code> <p>Set DSCP/TOS/TCLASS field to outgoing packets. Use OS defaults when empty.</p> <p>Warning</p> <p>This option is ignored on IPv6 socket due to issue #2</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Default timeout in seconds.</p> <code>1.0</code> <code>send_buffer_size</code> <code>int | None</code> <p>Send buffer size. Use OS defaults when empty.</p> <code>None</code> <code>recv_buffer_size</code> <code>int | None</code> <p>Receive buffer size. Use OS defaults when empty.</p> <code>None</code> <code>coarse</code> <code>bool</code> <p>Use CLOCK_MONOTONIC_COARSE when set, fall back to CLOCK_MONOTONIC otherwise.</p> <code>False</code> Note <p>Opening the Raw Socket may require super-user priveleges or additional permissions. Refer to the operation system's documentation for details.</p> Example <p>Ping single packet.</p> <pre><code>from gufo.ping import Ping\n\nasync def ping(address):\n    p = Ping()\n    rtt = await p.ping(address)\n    print(rtt)\n</code></pre> <p>Ping multiple packets.</p> <pre><code>from gufo.ping import Ping\n\nasync def ping(address):\n    p = Ping()\n    async for rtt in p.iter_rtt(address):\n        print(rtt)\n</code></pre>"},{"location":"reference/gufo/ping/#gufo.ping.Ping.__get_socket","title":"<code>__get_socket(address)</code>","text":"<p>Get PingSocket instace.</p> <p>Get ping socket instance for specified address. Initialize when necessary.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Address to ping</p> required <p>Returns:</p> Type Description <code>PingSocket</code> <p>Initialized socket instance</p>"},{"location":"reference/gufo/ping/#gufo.ping.Ping.iter_rtt","title":"<code>iter_rtt(addr, *, size=None, interval=1.0, count=None)</code>  <code>async</code>","text":"<p>Do the serie of ping probes.</p> <p>Send echo request every <code>interval</code> seconds, await and yield the result.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>Address to ping.</p> required <code>size</code> <code>int | None</code> <p>Packets' size, including IP headers. Use PingSocket intialized defaults, when empty.</p> <code>None</code> <code>interval</code> <code>float | None</code> <p>Interval between requests, in seconds.</p> <code>1.0</code> <code>count</code> <code>int | None</code> <p>Stop after <code>count</code> requests, if set. Do not stop otherwise.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterable[float | None]</code> <p>Yields for each attempt:</p> <code>AsyncIterable[float | None]</code> <ul> <li>Round-trip time in seconds (as float) if success.</li> </ul> <code>AsyncIterable[float | None]</code> <ul> <li>None - if failed or timed out.</li> </ul>"},{"location":"reference/gufo/ping/#gufo.ping.Ping.ping","title":"<code>ping(addr, size=None)</code>  <code>async</code>","text":"<p>Do ping probe.</p> <p>Send ICMP echo request to the given address and await for response or timeout.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>IPv4/IPv6 address to ping.</p> required <code>size</code> <code>int | None</code> <p>Packet's size, including IP headers. Use PingSocket intialized defaults, when empty.</p> <code>None</code> <p>Returns:</p> Type Description <code>float | None</code> <ul> <li>Round-trip time in seconds (as float) if success.</li> </ul> <code>float | None</code> <ul> <li>None - if failed or timed out.</li> </ul>"},{"location":"reference/gufo/ping/#gufo.ping.SelectionPolicy","title":"<code>SelectionPolicy</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Probe selection policy.</p> <p>Allows automatical selection between implementations:</p> <ul> <li><code>RAW</code> - Raw sockets, requires root user (POSIX platforms)     or CAP_NET_RAW capability (Linux).</li> <li><code>DGRAM</code> - ICMP datagram socket (Linux only). Requires     <code>net.ipv4.ping_group_range</code> to contain process' group.</li> </ul> <p>Attributes:</p> Name Type Description <code>RAW</code> <p>Use RAW only.</p> <code>RAW_DGRAM</code> <p>Try RAW, fallback to DGRAM.</p> <code>DGRAM_RAW</code> <p>Try DGRAM, fallback to RAW.</p> <code>DGRAM</code> <p>Use DGRAM only.</p>"},{"location":"reference/gufo/ping/cli/","title":"gufo.ping.cli","text":"<p><code>gufo-ping</code> command line utility.</p> <p>Attributes:</p> Name Type Description <code>NAME</code> <p>Utility's name.</p>"},{"location":"reference/gufo/ping/cli/#gufo.ping.cli.Cli","title":"<code>Cli</code>","text":"<p>               Bases: <code>object</code></p> <p><code>gufo-ping</code> utility class.</p>"},{"location":"reference/gufo/ping/cli/#gufo.ping.cli.Cli.die","title":"<code>die(msg=None)</code>  <code>classmethod</code>","text":"<p>Die with message.</p>"},{"location":"reference/gufo/ping/cli/#gufo.ping.cli.Cli.run","title":"<code>run(args)</code>","text":"<p>Parse command-line arguments and run appropriate command.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>list[str]</code> <p>List of command-line arguments</p> required <p>Returns:     ExitCode</p>"},{"location":"reference/gufo/ping/cli/#gufo.ping.cli.ExitCode","title":"<code>ExitCode</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Cli exit codes.</p> <p>Attributes:</p> Name Type Description <code>OK</code> <p>Successful exit</p>"},{"location":"reference/gufo/ping/cli/#gufo.ping.cli.main","title":"<code>main(args=None)</code>","text":"<p>Run <code>gufo-ping</code> with command-line arguments.</p>"},{"location":"reference/gufo/ping/ping/","title":"gufo.ping.ping","text":"<p>Ping client implementation.</p>"},{"location":"reference/gufo/ping/ping/#gufo.ping.ping.Ping","title":"<code>Ping</code>","text":"<p>               Bases: <code>object</code></p> <p>High-performance asyncronous ICMPv4/ICMPv6 ping client.</p> <p>Parameters:</p> Name Type Description Default <code>policy</code> <code>SelectionPolicy</code> <p>Probe selection policy.</p> <code>RAW</code> <code>size</code> <code>int</code> <p>Set outgoing packet's size, including IP header.</p> <code>64</code> <code>src_addr</code> <code>None | str | Iterable[str]</code> <p>Set source address for outgoing packets. Depends upon address family. May be one of: * None - detect source address automatically. * str - containing source address for one address family. * Iterable of strings, containing multiple addresses     which to be distributed among the address families.     First address for given address family will be used.</p> <code>None</code> <code>ttl</code> <code>int | None</code> <p>Set outgoing packet's TTL. Use OS defaults when empty.</p> <p>Warning</p> <p>This option is ignored on IPv6 socket due to issue #4</p> <code>None</code> <code>tos</code> <code>int | None</code> <p>Set DSCP/TOS/TCLASS field to outgoing packets. Use OS defaults when empty.</p> <p>Warning</p> <p>This option is ignored on IPv6 socket due to issue #2</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Default timeout in seconds.</p> <code>1.0</code> <code>send_buffer_size</code> <code>int | None</code> <p>Send buffer size. Use OS defaults when empty.</p> <code>None</code> <code>recv_buffer_size</code> <code>int | None</code> <p>Receive buffer size. Use OS defaults when empty.</p> <code>None</code> <code>coarse</code> <code>bool</code> <p>Use CLOCK_MONOTONIC_COARSE when set, fall back to CLOCK_MONOTONIC otherwise.</p> <code>False</code> Note <p>Opening the Raw Socket may require super-user priveleges or additional permissions. Refer to the operation system's documentation for details.</p> Example <p>Ping single packet.</p> <pre><code>from gufo.ping import Ping\n\nasync def ping(address):\n    p = Ping()\n    rtt = await p.ping(address)\n    print(rtt)\n</code></pre> <p>Ping multiple packets.</p> <pre><code>from gufo.ping import Ping\n\nasync def ping(address):\n    p = Ping()\n    async for rtt in p.iter_rtt(address):\n        print(rtt)\n</code></pre>"},{"location":"reference/gufo/ping/ping/#gufo.ping.ping.Ping.__get_socket","title":"<code>__get_socket(address)</code>","text":"<p>Get PingSocket instace.</p> <p>Get ping socket instance for specified address. Initialize when necessary.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Address to ping</p> required <p>Returns:</p> Type Description <code>PingSocket</code> <p>Initialized socket instance</p>"},{"location":"reference/gufo/ping/ping/#gufo.ping.ping.Ping.iter_rtt","title":"<code>iter_rtt(addr, *, size=None, interval=1.0, count=None)</code>  <code>async</code>","text":"<p>Do the serie of ping probes.</p> <p>Send echo request every <code>interval</code> seconds, await and yield the result.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>Address to ping.</p> required <code>size</code> <code>int | None</code> <p>Packets' size, including IP headers. Use PingSocket intialized defaults, when empty.</p> <code>None</code> <code>interval</code> <code>float | None</code> <p>Interval between requests, in seconds.</p> <code>1.0</code> <code>count</code> <code>int | None</code> <p>Stop after <code>count</code> requests, if set. Do not stop otherwise.</p> <code>None</code> <p>Returns:</p> Type Description <code>AsyncIterable[float | None]</code> <p>Yields for each attempt:</p> <code>AsyncIterable[float | None]</code> <ul> <li>Round-trip time in seconds (as float) if success.</li> </ul> <code>AsyncIterable[float | None]</code> <ul> <li>None - if failed or timed out.</li> </ul>"},{"location":"reference/gufo/ping/ping/#gufo.ping.ping.Ping.ping","title":"<code>ping(addr, size=None)</code>  <code>async</code>","text":"<p>Do ping probe.</p> <p>Send ICMP echo request to the given address and await for response or timeout.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>IPv4/IPv6 address to ping.</p> required <code>size</code> <code>int | None</code> <p>Packet's size, including IP headers. Use PingSocket intialized defaults, when empty.</p> <code>None</code> <p>Returns:</p> Type Description <code>float | None</code> <ul> <li>Round-trip time in seconds (as float) if success.</li> </ul> <code>float | None</code> <ul> <li>None - if failed or timed out.</li> </ul>"},{"location":"reference/gufo/ping/proto/","title":"gufo.ping.proto","text":"<p>SocketWrapper protocol definition.</p>"},{"location":"reference/gufo/ping/proto/#gufo.ping.proto.SocketProto","title":"<code>SocketProto</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>SocketWrapper protocol.</p> <p>Socket wrapper is the PyO3-wrapped Rust code, implementing low-level details of the PingSocket.</p>"},{"location":"reference/gufo/ping/proto/#gufo.ping.proto.SocketProto.bind","title":"<code>bind(addr)</code>","text":"<p>Bind to source address.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>Source Address</p> required"},{"location":"reference/gufo/ping/proto/#gufo.ping.proto.SocketProto.clean_ip","title":"<code>clean_ip(addr)</code>","text":"<p>Normalize IP address to a stable form.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>IP address</p> required <p>Returns:</p> Type Description <code>str</code> <p>Normalized address</p>"},{"location":"reference/gufo/ping/proto/#gufo.ping.proto.SocketProto.get_fd","title":"<code>get_fd()</code>","text":"<p>Get socket's file descriptor.</p> <p>Returns:</p> Type Description <code>int</code> <p>file descriptor for open socket.</p>"},{"location":"reference/gufo/ping/proto/#gufo.ping.proto.SocketProto.recv","title":"<code>recv()</code>","text":"<p>Receive all awaiting packets.</p> <p>Returns:</p> Type Description <code>dict[int, float] | None</code> <ul> <li><code>None</code> - when no packets received.</li> </ul> <code>dict[int, float] | None</code> <ul> <li>Dict of <code>session id</code> -&gt; <code>rtt</code>, where <code>session id</code> is the value, returned by <code>send</code> and <code>rtt</code> - is the measured round-trip-time in nanoseconds.</li> </ul>"},{"location":"reference/gufo/ping/proto/#gufo.ping.proto.SocketProto.send","title":"<code>send(addr, size)</code>","text":"<p>Generate and send icmp request packet.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>Destination address.</p> required <code>size</code> <code>int</code> <p>Outgoing packet's size in bytes, including IP header.</p> required <p>Returns:</p> Type Description <code>int</code> <p>session id.</p>"},{"location":"reference/gufo/ping/proto/#gufo.ping.proto.SocketProto.set_recv_buffer_size","title":"<code>set_recv_buffer_size(size)</code>","text":"<p>Set incoming socket's buffer size.</p> <p>If the requested size is too big, adjust to proper size.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Requested recv buffer size, in bytes.</p> required"},{"location":"reference/gufo/ping/proto/#gufo.ping.proto.SocketProto.set_send_buffer_size","title":"<code>set_send_buffer_size(size)</code>","text":"<p>Set outgoing socket's buffer size.</p> <p>If the requested size is too big, adjust to proper size.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Requested send buffer size, in bytes.</p> required"},{"location":"reference/gufo/ping/proto/#gufo.ping.proto.SocketProto.set_tclass","title":"<code>set_tclass(tclass)</code>","text":"<p>Change outgoing packets' IPv6 TCLASS field.</p> <p>Parameters:</p> Name Type Description Default <code>tclass</code> <code>int</code> <p>TCLASS value.</p> required"},{"location":"reference/gufo/ping/proto/#gufo.ping.proto.SocketProto.set_tos","title":"<code>set_tos(tos)</code>","text":"<p>Change outgoing packets' ToS/DSCP field.</p> <p>Parameters:</p> Name Type Description Default <code>tos</code> <code>int</code> <p>ToS value.</p> required"},{"location":"reference/gufo/ping/proto/#gufo.ping.proto.SocketProto.set_ttl","title":"<code>set_ttl(ttl)</code>","text":"<p>Change outgoing packets' time-to-live field.</p> <p>Parameters:</p> Name Type Description Default <code>ttl</code> <code>int</code> <p>TTL value.</p> required"},{"location":"reference/gufo/ping/proto/#gufo.ping.proto.SocketProto.set_unicast_hops","title":"<code>set_unicast_hops(ttl)</code>","text":"<p>Change outgoing packets' unicast hops (IPv6 TTL).</p> <p>Parameters:</p> Name Type Description Default <code>ttl</code> <code>int</code> <p>TTL value.</p> required"},{"location":"reference/gufo/ping/socket/","title":"gufo.ping.socket","text":"<p>PingSocket implementation.</p> <p>Attributes:</p> Name Type Description <code>IPv4</code> <p>IPv4 address family.</p> <code>IPv6</code> <p>IPv6 address family.</p>"},{"location":"reference/gufo/ping/socket/#gufo.ping.socket.PingSocket","title":"<code>PingSocket</code>","text":"<p>               Bases: <code>object</code></p> <p>Python API to Gufo Ping internals.</p> <p>Python-side ICMP requests/reply dispatcher for the given address family. Wraps Rust socket implementation.</p> <p>Parameters:</p> Name Type Description Default <code>afi</code> <code>int</code> <p>Address Family. Either IPv4 or IPv6.</p> <code>IPv4</code> <code>policy</code> <code>SelectionPolicy</code> <p>Probe selection policy.</p> <code>RAW</code> <code>size</code> <code>int</code> <p>Set outgoing packet's size, including IP header.</p> <code>64</code> <code>src_addr</code> <code>str | None</code> <p>Optional source address of outgoing packets.</p> <code>None</code> <code>ttl</code> <code>int | None</code> <p>Set outgoing packet's TTL. Use OS defaults when empty.</p> <code>None</code> <code>tos</code> <code>int | None</code> <p>Set DSCP/TOS field to outgoing packets. Use OS defaults when empty.</p> <code>None</code> <code>timeout</code> <code>float</code> <p>Default timeout in seconds.</p> <code>1.0</code> <code>send_buffer_size</code> <code>int | None</code> <p>Send buffer size. Use OS defaults when empty.</p> <code>None</code> <code>recv_buffer_size</code> <code>int | None</code> <p>Receive buffer size. Use OS defaults when empty.</p> <code>None</code> <code>coarse</code> <code>bool</code> <p>Use CLOCK_MONOTONIC_COARSE when set, fall back to CLOCK_MONOTONIC otherwise.</p> <code>False</code>"},{"location":"reference/gufo/ping/socket/#gufo.ping.socket.PingSocket.__del__","title":"<code>__del__()</code>","text":"<p>Perform cleanup on delete.</p>"},{"location":"reference/gufo/ping/socket/#gufo.ping.socket.PingSocket.clean_ip","title":"<code>clean_ip(addr)</code>","text":"<p>Normalize IP address to a stable form.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>IP address</p> required <p>Returns:</p> Type Description <code>str</code> <p>Normalized address</p>"},{"location":"reference/gufo/ping/socket/#gufo.ping.socket.PingSocket.ping","title":"<code>ping(addr, size=None)</code>  <code>async</code>","text":"<p>Send ICMP echo request and await for result.</p> <p>Parameters:</p> Name Type Description Default <code>addr</code> <code>str</code> <p>Socket to ping.</p> required <code>size</code> <code>int | None</code> <p>Packet size in bytes, including IP header.</p> <code>None</code>"},{"location":"reference/gufo/ping/socket/#gufo.ping.socket.SelectionPolicy","title":"<code>SelectionPolicy</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>Probe selection policy.</p> <p>Allows automatical selection between implementations:</p> <ul> <li><code>RAW</code> - Raw sockets, requires root user (POSIX platforms)     or CAP_NET_RAW capability (Linux).</li> <li><code>DGRAM</code> - ICMP datagram socket (Linux only). Requires     <code>net.ipv4.ping_group_range</code> to contain process' group.</li> </ul> <p>Attributes:</p> Name Type Description <code>RAW</code> <p>Use RAW only.</p> <code>RAW_DGRAM</code> <p>Try RAW, fallback to DGRAM.</p> <code>DGRAM_RAW</code> <p>Try DGRAM, fallback to RAW.</p> <code>DGRAM</code> <p>Use DGRAM only.</p>"}]}